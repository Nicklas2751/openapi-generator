/*
 * OpenAPI Petstore
 * This spec is mainly for testing Petstore server and contains fake endpoints, models. Please do not use this for any other purpose. Special characters: \" \\
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.auth;

import org.openapitools.client.ApiException;

import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.security.InvalidKeyException;
import java.security.Key;
import java.security.MessageDigest;
import java.security.spec.AlgorithmParameterSpec;
import java.text.SimpleDateFormat;
import java.util.Base64;
import java.util.Calendar;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.TimeZone;
import java.util.stream.Collectors;

import org.tomitribe.auth.signatures.Algorithm;
import org.tomitribe.auth.signatures.Signer;
import org.tomitribe.auth.signatures.Signature;
import org.tomitribe.auth.signatures.SigningAlgorithm;

/**
 * A Configuration object for the HTTP message signature security scheme.
 */
public class HttpSignatureAuth implements Authentication {

  public static final String HEADER_HOST = "host";
  public static final String HEADER_DATE = "date";
  public static final String HEADER_DIGEST = "digest";
  public static final String DATE_HEADER_DATE_FORMAT = "EEE, dd MMM yyyy HH:mm:ss z";
  public static final String DATE_HEADER_TIMEZONE = "GMT";
  private Signer signer;

  // An opaque string that the server can use to look up the component they need to validate the signature.
  private String keyId;

  // The HTTP signature algorithm.
  private SigningAlgorithm signingAlgorithm;

  // The HTTP cryptographic algorithm.
  private Algorithm algorithm;

  // The cryptographic parameters.
  private AlgorithmParameterSpec parameterSpec;

  // The list of HTTP headers that should be included in the HTTP signature.
  private List<String> headers;

  // The digest algorithm which is used to calculate a cryptographic digest of the HTTP request body.
  private String digestAlgorithm;

  // The maximum validity duration of the HTTP signature.
  private final Long maxSignatureValidity;

  /**
   * Construct a new HTTP signature auth configuration object.
   *
   * @param keyId An opaque string that the server can use to look up the component they need to validate the signature.
   * @param signingAlgorithm The signature algorithm.
   * @param algorithm The cryptographic algorithm.
   * @param digestAlgorithm The digest algorithm.
   * @param headers The list of HTTP headers that should be included in the HTTP signature.
   * @param maxSignatureValidity The maximum validity duration of the HTTP signature.
   *                             Used to set the '(expires)' field in the HTTP signature.
   */
  public HttpSignatureAuth(String keyId,
                           SigningAlgorithm signingAlgorithm,
                           Algorithm algorithm,
                           String digestAlgorithm,
                           AlgorithmParameterSpec parameterSpec,
                           List<String> headers,
                           Long maxSignatureValidity) {
    this.keyId = keyId;
    this.signingAlgorithm = signingAlgorithm;
    this.algorithm = algorithm;
    this.parameterSpec = parameterSpec;
    this.digestAlgorithm = digestAlgorithm;
    this.headers = headers;
    this.maxSignatureValidity = maxSignatureValidity;
  }

  /**
   * Returns the opaque string that the server can use to look up the component they need to validate the signature.
   *
   * @return The keyId.
   */
  public String getKeyId() {
    return keyId;
  }

  /**
   * Set the HTTP signature key id.
   *
   * @param keyId An opaque string that the server can use to look up the component they need to validate the signature.
   */
  public void setKeyId(String keyId) {
    this.keyId = keyId;
  }

  /**
   * Returns the HTTP signature algorithm which is used to sign HTTP requests.
   */
  public SigningAlgorithm getSigningAlgorithm() {
    return signingAlgorithm;
  }

  /**
   * Sets the HTTP signature algorithm which is used to sign HTTP requests.
   *
   * @param signingAlgorithm The HTTP signature algorithm.
   */
  public void setSigningAlgorithm(SigningAlgorithm signingAlgorithm) {
    this.signingAlgorithm = signingAlgorithm;
  }

  /**
   * Returns the HTTP cryptographic algorithm which is used to sign HTTP requests.
   */
  public Algorithm getAlgorithm() {
    return algorithm;
  }

  /**
   * Sets the HTTP cryptographic algorithm which is used to sign HTTP requests.
   *
   * @param algorithm The HTTP signature algorithm.
   */
  public void setAlgorithm(Algorithm algorithm) {
    this.algorithm = algorithm;
  }

  /**
   * Returns the cryptographic parameters which are used to sign HTTP requests.
   */
  public AlgorithmParameterSpec getAlgorithmParameterSpec() {
    return parameterSpec;
  }

  /**
   * Sets the cryptographic parameters which are used to sign HTTP requests.
   *
   * @param parameterSpec The cryptographic parameters.
   */
  public void setAlgorithmParameterSpec(AlgorithmParameterSpec parameterSpec) {
    this.parameterSpec = parameterSpec;
  }

  /**
   * Returns the digest algorithm which is used to calculate a cryptographic digest of the HTTP request body.
   *
   * @see java.security.MessageDigest
   */
  public String getDigestAlgorithm() {
    return digestAlgorithm;
  }

  /**
   * Sets the digest algorithm which is used to calculate a cryptographic digest of the HTTP request body.
   *
   * The exact list of supported digest algorithms depends on the installed security providers.
   * Every implementation of the Java platform is required to support "MD5", "SHA-1" and "SHA-256".
   * Do not use "MD5" and "SHA-1", they are vulnerable to multiple known attacks.
   * By default, "SHA-256" is used.
   *
   * @param digestAlgorithm The digest algorithm.
   *
   * @see java.security.MessageDigest
   */
  public void setDigestAlgorithm(String digestAlgorithm) {
    this.digestAlgorithm = digestAlgorithm;
  }

  /**
   * Returns the list of HTTP headers that should be included in the HTTP signature.
   */
  public List<String> getHeaders() {
    return headers;
  }

  /**
   * Sets the list of HTTP headers that should be included in the HTTP signature.
   *
   * @param headers The HTTP headers.
   */
  public void setHeaders(List<String> headers) {
    this.headers = headers;
  }

  /**
   * Returns the maximum validity duration of the HTTP signature.
   * @return The maximum validity duration of the HTTP signature.
   */
  public Long getMaxSignatureValidity() {
    return maxSignatureValidity;
  }

  /**
   * Returns the signer instance used to sign HTTP messages.
   *
   * @return the signer instance.
   */
  public Signer getSigner() {
    return signer;
  }

  /**
   * Sets the signer instance used to sign HTTP messages.
   *
   * @param signer The signer instance to set.
   */
  public void setSigner(Signer signer) {
    this.signer = signer;
  }

  /**
   * Set the private key used to sign HTTP requests using the HTTP signature scheme.
   *
   * @param key The private key.
   *
   * @throws InvalidKeyException Unable to parse the key, or the security provider for this key
   * is not installed.
   */
  public void setPrivateKey(Key key) throws InvalidKeyException, ApiException {
    if (key == null) {
      throw new ApiException("Private key (java.security.Key) cannot be null");
    }
    signer = new Signer(key, new Signature(keyId, signingAlgorithm, algorithm, parameterSpec, null, headers, maxSignatureValidity));
  }

  @Override
  public void applyToParams(HttpRequest.Builder requestBuilder, HttpClient httpClient) throws ApiException {
    var httpRequest = requestBuilder.copy().build();
    var headersToSign = new HashMap<>(headerListValueMapToSingleValueMap(httpRequest));
    var uri = httpRequest.uri();
    var payload = httpRequest.bodyPublisher()
            .map(Object::toString)
            .orElse("");

    try {
      if (headers.contains(HEADER_HOST)) {
        headersToSign.put(HEADER_HOST, uri.getHost());
      }

      if (headers.contains(HEADER_DATE)) {
        SimpleDateFormat dateFormat = new SimpleDateFormat(DATE_HEADER_DATE_FORMAT, Locale.US);
        dateFormat.setTimeZone(TimeZone.getTimeZone(DATE_HEADER_TIMEZONE));
        headersToSign.put(HEADER_DATE, dateFormat.format(Calendar.getInstance().getTime()));
      }

      if (headers.contains(HEADER_DIGEST)) {
        headersToSign.put(HEADER_DIGEST,
                this.digestAlgorithm + "=" +
                        new String(Base64.getEncoder().encode(MessageDigest.getInstance(this.digestAlgorithm).digest(payload.getBytes()))));
      }

      if (signer == null) {
        throw new ApiException("Signer cannot be null. Please call the method `setPrivateKey` to set it up correctly");
      }

      // construct the path with the URL-encoded path and query.
      // Calling getRawPath and getRawQuery ensures the path is URL-encoded as it will be serialized
      // on the wire. The HTTP signature must use the encode URL as it is sent on the wire.
      String path = uri.getRawPath();
      if (uri.getRawQuery() != null && !uri.getRawQuery().isEmpty()) {
        path += "?" + uri.getRawQuery();
      }

      requestBuilder.header("Authorization", signer.sign(httpRequest.method(), path, headersToSign).toString());
    } catch (Exception ex) {
      throw new ApiException("Failed to create signature in the HTTP request header: " + ex);
    }
  }

  /**
   * Converts the HTTP request headers from a list of values to a single value map.
   * This is useful for signing the HTTP request, as the signature should only include the first value of each header.
   *
   * @param httpRequest The HTTP request to convert.
   * @return A map of header names to their first value.
   */
  protected Map<String, String> headerListValueMapToSingleValueMap(HttpRequest httpRequest) {
    return httpRequest.headers().map().entrySet().stream()
            .collect(Collectors.toMap(Map.Entry::getKey, entry -> entry.getValue().get(0)));
  }
}
